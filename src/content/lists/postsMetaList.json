[{"number":31,"title":"徹底搞懂javascript原型鍊","createdAt":"2023-09-10T14:43:46Z","publishedAt":"2023-09-10T14:43:46Z","lastEditedAt":"2023-10-04T04:45:21Z","url":"https://github.com/superyngo/hakuba_template/discussions/31","category":{"name":"posts"},"labels":{"nodes":[{"name":"javcascript","color":"509AB1"}]},"year":"2023","month":"9","date":"10","body":"---\nnumber: 31\ntitle: 徹底搞懂javascript原型鍊\ncreatedAt: 2023-09-10T14:43:46Z\npublishedAt: 2023-09-10T14:43:46Z\nlastEditedAt: 2023-10-04T04:45:21Z\nurl: https://github.com/superyngo/hakuba_template/discussions/31\ncategory:\n  name: posts\nlabels:\n  nodes:\n    - name: javcascript\n      color: 509AB1\nyear: \"2023\"\nmonth: \"9\"\ndate: \"10\"\n---\nJavascript的物件導向是基於原型鍊實現，這個原型鍊基本上由：  \r\n1. 原型function.prototype  \r\n2. 原型function.prototype.constructor  \r\n3. `object.__proto__`   \r\n構成，搞懂這3者的意義和交互關係就能徹底搞懂原型鍊。  \r\n\r\n## function.prototype.constructor===function\r\n在有class以前，我們在原型function內使用this定義property以打造object的內容，並用new產出帶有這些property的object。  \r\n通常會稱這個原型function是constructor，這個稱呼雖然從功能上看沒有錯，但其實，所謂constructor是任何function都\"間接\"會有的method。為了釐清，我們稱有constructor功能的function為「原型function」。\r\n至於為何是\"間接\"呢，因為在定義function時，function內會自動長出一個特別的property：prototype。  \r\nfunction.prototype本身是個object，其內就包含了所謂的constructor，而constructor作為function.prototype的一個method，其功能就是原型function本身，形成cyclic object的結構：`function.prototype.constructor===function` 。\r\n\r\n### object的種子：constructor\r\nconstructor的功能，就像種子一樣，用this.property幫助object建立屬於自己的基本property，例如：  \r\n```js\r\nfunction Dog (name){\r\n  this.name=name\r\n}\r\nconst snoopy= new Dog(\"Snoopy\")\r\nsnoopy.name //\"Snoopy\"\r\n```\r\n當我們用new去執行原型function時，會先創造一個空object，再把原型function種在這個空object內(把this指向空object)，讓其發芽(執行)，藉此把其內用this定義的property在空object內長出來。至於原型function是怎麼以constructor的形式跑進空object內的，我們稍後解釋。  \r\n\r\n### object的根：prototype\r\nobject不只可從prorotype獲得種子(constructor)，還可呼叫其所有的property及method\r\n，這就是為何原型function要用多一層的function.prototype把自己包起來：透過這多一層包裝，就可以在constructor外定義其他method讓後代子孫使用，也因此在class出現前，原型method要定義在原型function.prototype上。（ 說穿了，class就是包起來的原型function.ptototype)\r\n```js\r\nfunction Dog(name){\r\n  this.name=name\r\n}\r\nDog.prototype.bark=function(){\r\n  console.log(this.name + \"bark!\")\r\n}\r\nconst snoopy = new Dog(\"Snoopy\")\r\nsnoopy.bark() // \"Snoopy bark!\"\r\n```\r\n### object的莖：`__proto__`\r\n說完prototype及constructor，有沒有發現，這兩者雖是object的根和種子，卻都長在原型function上，那他們是怎麼和object連起來的？  \r\n沒錯，就是透過`__proto__`這個getter/setter，設定object的原型到指定的prototype或object上。有趣的是，`__proto__`其實是object之母：Object.prototype提供的property(getter/setter)，透過向後提供這個property，才讓其所後所有object都能向前接回其身。  \r\n那麼作為object之母的Object.prototype，若令其呼叫`__proto__`會得到誰呢？答案是null，而且嘗試再用`Object.prototype.__proto__`做任何設定都會出錯，這讓null成為所有原型鍊的起點。\r\n\r\n## 手動模擬prototype原型鍊\r\n\r\n複習一下：`__proto__`是所有object都能使用的setter/getter，定義在object之母Object.prototype上；Object.prototype則是Object作為一個function，必定擁有的property，這個property既把Object作為原型function包成constructor這個method，其上所定義的其他method也都可被後代呼叫。  \r\n當用new+原型function去創建object時，首先會先創建一個空object，接著用`object.__proto__`設定其原型至原型function.prototype上，最後執行`object.constructor()`(也就是在空object上執行原型function)將原型function內用this定義的property長出來。  \r\n既然原型function.prototype就是包含了constructor在內各種method或property的object，只是長在function裡面而以，那我們其實不需要原型function，甚至也不需使用new，只要實作一個擁有constructor method在內的object，就可以複製原型鍊的效果，以下以code實作：  \r\n```js\r\n//先實作一個fake prototype\r\nconst fakePrototype={\r\n  constructor(name){\r\n     this.name=name\r\n  },\r\n  sayMyName(){console.log(this.name)}\r\n}\r\n//做一個空object並將其原型設定到fake prototype\r\nconst obj={}\r\nobj.__proto__=fakePrototype\r\nconsole.log(obj) // {} 此時obj還是空的\r\nobj.constructor(\"John\")\r\nconsole.log(obj) // { name: \"John\" } 透過this.name長出屬於自己的name property\r\nobj.sayMyName() // John   這邊呼叫了其原型fakePrototype的方法\r\n```\r\n有沒有發現fakePrototype長得和什麼很像？沒錯，就是class！所以才說class就是經過包裝的原型function.prototype。只是fakePrototype是object，而class的寫法(格式)則和function一樣。\r\n\r\n### 改用Object.create試看看\r\n我們也可以用Object.create模擬：\r\n```js\r\n//接續上面的模擬，這次直接用fakePrototype生出一個物件\r\nconst obj2=Object.create(fakePrototype)\r\nconsole.log(obj2) // {} 此時obj還是空的\r\nobj2.constructor(\"John\")\r\nconsole.log(obj2) // { name: \"John\" } 透過this.name長出屬於自己的name property\r\nobj2.sayMyName() // John  這邊呼叫了其原型fakePrototype的方法\r\n```\r\n從上面的模擬也可以發現，Object.create實際上就做了2件事：創造空object、把空object的`__proto__`設定為目標object。如此產生的object也是空的，只是可以取用其原型上的所有property而已。若想像用new+原型function快速在這個空object內長出property，很簡單，就再執行一次object.constructor()就可以：\r\n```js\r\n//接續上面的模擬，但改將obj2當作prototype\r\nconst obj3=Object.create(obj2)\r\nconsole.log(obj3) // {} 此時obj3也是空的\r\nobj3.sayMyName() // John   雖然是空的，但可以讀取到其原型obj2的property name，以及呼叫obj2原型fakePrototype的method：sayMyName\r\nobj3.constructor(\"Mary\")\r\nconsole.log(obj3) // { name: \"Mary\" }  透過constructor中的this.name長出屬於自己的name property，因此不會再去讀取obj2的name了\r\n```\r\n## 相關問題\r\n\r\n### prototype method/property vs this.methods/property within constructor\r\n我們已了解在製造原型時，定義在prototype上的method都可被後代子孫取用，那如果改在constructor內用this定義method呢？兩者又有何差別？\r\n```js\r\n//這邊直接用class方便呈現\r\nclass Dog{\r\n  constructor(name){\r\n    this.name=name\r\n  };\r\n  bark(){console.log(this.name + \" bark!\")}\r\n}\r\n\r\nclass Dog{\r\n  constructor(name){\r\n    this.name=name;\r\n    this.bark(){console.log(this.name + \" bark!\")}\r\n  };\r\n}\r\n```\r\n最主要的差別是，定義在prototype上的method屬於原型方法，後代子孫在取用時都屬於同一instance，而定義在constructor內的method則會長在所有後代子孫內，導致占用更多記憶體資源。\r\n\r\n### function及其他javascript原生type的prototype\r\n我們已理解`__proto__`在object上的功能，那在object以外的「東西」上呼叫`__proto__`呢？  \r\n眾所皆知，javascript內所有「東西」都是object，而`__proto__`又是所有object都可呼叫的property，而在一般object外的任何「東西」上呼叫`__proto__`，就可取得該「東西」的原型function(constructor)下的特殊prototype。\r\n例如：\r\n```js\r\n\"abc\".__proto__===String.prototype \r\n[].__proto__===Array.prototype \r\nfunction abc(){}\r\nabc.__proto__===Function.prototype\r\n```\r\njavascript內各種不同type的「東西」，就是由這些特殊prototype所構成。而其中最特別的就是Function.prototype，他本身是所有function的`__proto__`設定對象，包含Function自己，所以`Function.prototype===Function.__proto__`。\r\n此外，Function.prototype也是唯一個一不是一般object，而是function的prototype，而這個作為prototype的function，也是唯一一個沒有prototype property的function。可見Object.prototype是object之母，或許可以稱Function.prototype是object之父。\r\n\r\n最後考考大家，Object.prototype是object之母，那`Object.__proto__`是什麼？  \r\n  \r\n  \r\n   \r\n  \r\n    \r\n答案是Function.prototype，因為Object也是function(原型function/constructor也是function)。\r\n\r\n講到這邊，相信已基本釐清javascript原型鍊如何運作，那後面就可以接著探討factory function和class/原型function的差別。先洩漏關鍵字：closure。\r\n\r\n參考資料：\r\n[Day13 前端蛇行撞牆記 - Constructor function 建構式函式](https://ithelp.ithome.com.tw/articles/10300139)\r\n"},{"number":26,"title":"用google-spreadsheet將表格轉為object","createdAt":"2023-09-05T02:03:27Z","publishedAt":"2023-09-05T02:03:27Z","lastEditedAt":"2023-09-05T02:27:51Z","url":"https://github.com/superyngo/hakuba_template/discussions/26","category":{"name":"posts"},"labels":{"nodes":[{"name":"Google Sheet Api","color":"971598"}]},"year":"2023","month":"9","date":"5","body":"---\nnumber: 26\ntitle: 用google-spreadsheet將表格轉為object\ncreatedAt: 2023-09-05T02:03:27Z\npublishedAt: 2023-09-05T02:03:27Z\nlastEditedAt: 2023-09-05T02:27:51Z\nurl: https://github.com/superyngo/hakuba_template/discussions/26\ncategory:\n  name: posts\nlabels:\n  nodes:\n    - name: Google Sheet Api\n      color: \"971598\"\nyear: \"2023\"\nmonth: \"9\"\ndate: \"5\"\n---\n安裝依賴開通Google sheet api和設定sheet權限部分請見[上篇  ](https://yafdn.vercel.app/articles/2023/8/30/24)  \r\n這篇要示範如何在svelte/kit將sheet轉為object  \r\n\r\n```js\r\nimport {json} from \"@sveltejs/kit\";// 傳出api要用\r\nimport {GoogleSpreadsheet} from \"google-spreadsheet\";\r\nimport {google} from \"googleapis\";\r\nimport {env} from \"$env/dynamic/private\"; // 環境變數(Google帳密)引入\r\n\r\nconst getGithubList = async function ( googleSheetsEnv ) {\r\n  //帶入docID及sheetID\r\n  const {docID, sheetID} = googleSheetsEnv;\r\n\r\n  //設定服務帳號帳密\r\n  const scopes = [\r\n    \"https://www.googleapis.com/auth/spreadsheets\",\r\n    \"https://www.googleapis.com/auth/drive.file\",\r\n  ];\r\n  const jwt = new google.auth.JWT({\r\n    email: env.Google_JWT_client_email,\r\n    key: env.Google_JWT_private_key,\r\n    scopes,\r\n  });\r\n\r\n  // 載入sheet及Header Row\r\n  const doc = new GoogleSpreadsheet(docID, jwt);\r\n  await doc.loadInfo();\r\n  const sheet = doc.sheetsById[sheetID];\r\n  await sheet.loadHeaderRow(); // Load the header row\r\n  const headerRow = sheet.headerValues;\r\n\r\n  //將資料寫入result\r\n  const result: any[] = [];\r\n  const rows = await sheet.getRows();\r\n  rows.forEach((row) => {\r\n    result.push(\r\n      headerRow.reduce((obj, name) => {\r\n        obj[name] = row.get(name);\r\n        return obj;\r\n      }, {} as obj)\r\n    );\r\n  });\r\n  return result;\r\n};\r\n```\r\n最後再包成API引用  \r\n```js\r\n//設定Google Sheet參數(docID及sheetID)\r\nconst googleSheetsEnv = {\r\n  docID: \"1qiQk_cpa-2W26a3djoXJh_zR9Ay3CGphO01ceAf91zE\",\r\n  sheetID: 0,\r\n};\r\nlet myNavbarList = await getGithubList(googleSheetsEnv);\r\n\r\nexport async function GET(request) {\r\n  return json(myNavbarList);\r\n}\r\n```"},{"number":24,"title":"用google-spreadsheet完成作品集更新","createdAt":"2023-08-30T06:16:46Z","publishedAt":"2023-08-30T06:16:46Z","lastEditedAt":"2023-10-04T04:46:28Z","url":"https://github.com/superyngo/hakuba_template/discussions/24","category":{"name":"posts"},"labels":{"nodes":[{"name":"Google Sheet Api","color":"971598"}]},"year":"2023","month":"8","date":"30","body":"---\nnumber: 24\ntitle: 用google-spreadsheet完成作品集更新\ncreatedAt: 2023-08-30T06:16:46Z\npublishedAt: 2023-08-30T06:16:46Z\nlastEditedAt: 2023-10-04T04:46:28Z\nurl: https://github.com/superyngo/hakuba_template/discussions/24\ncategory:\n  name: posts\nlabels:\n  nodes:\n    - name: Google Sheet Api\n      color: \"971598\"\nyear: \"2023\"\nmonth: \"8\"\ndate: \"30\"\n---\n![tobias-fischer-PkbZahEG2Ng-unsplash](https://github.com/superyngo/hakuba_template/assets/12149732/510668d0-3d64-4f80-8f59-ae29d52054d8)\r\nPhoto by <a href=\"https://unsplash.com/@tofi?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Tobias Fischer</a> on <a href=\"https://unsplash.com/photos/PkbZahEG2Ng?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\r\n  \r\n## My NavBar\r\n  \r\n在本站之前，作品都放在Githib，基本上是參考[Let's Write](https://www.letswrite.tw/)做的[Demo](https://letswritetw.github.io/letswrite-food-check/)  \r\n在頁面下方有作品導航以及Github連結  \r\n作品導航是先單獨做一個[myNavba Page](https://superyngo.github.io/myNavbar/)  \r\n然後用[Google Tag Manager](https://tagmanager.google.com/#/home)把myNavba的iframe和Github連結塞進每件作品下方  \r\n非常方便 \r\n    \r\n## 用Google Sheet做資料庫  \r\n  \r\nmyNavba的資料不是寫死的  \r\n而是寫在[Google Sheet](https://docs.google.com/spreadsheets/d/1qiQk_cpa-2W26a3djoXJh_zR9Ay3CGphO01ceAf91zE/edit?usp=sharing)裡  \r\n再用Google Sheet Api動態撈取  \r\n作法也是參考August大大的[筆記文](https://www.letswrite.tw/google-excel-db/)\r\n\r\n不過想移植到本站時  \r\n因為是在server端(+page.server.ts)裡用node.js撈資料  \r\n最後使用了[google-spreadsheet](https://theoephraim.github.io/node-google-spreadsheet/)來完成    \r\n操作方式如下  \r\n\r\n### 開通權限  \r\n先在Google Cloud Console開通Sheet API    \r\n申請服務帳號下載credentials.json  \r\n並在Google Sheet將服務帳號加入編輯者  \r\n詳細步驟可參考[使用 Node.js 操作 Google Sheets API 讀寫試算表資料庫](https://www.wfublog.com/2023/04/nodejs-google-sheets-api-read-write.html)的前半部分  \r\n後半部因為我使用google-spreadsheet而非Google Api  \r\n說明如下  \r\n  \r\n### 先安裝依賴  \r\n```js\r\npnpm add -D google-spreadsheet googleapis\r\n```\r\n  \r\n### 載入credentials  \r\n```js\r\nimport {readFile} from \"fs/promises\";\r\n  const creds = JSON.parse(\r\n    await readFile(`src/lib/.credentials/${credentialsName}.json`, \"utf8\")\r\n  );\r\n// 原先嘗試用import直接動態載入\r\n// 需要在import內放入第2個變數{assert: {type: \"json\"}\r\n// 但是動態import還是試驗功能\r\n// 最後在svelte/kit內出錯，所以還是用readFile\r\n// 下面是用node動態import json的語法\r\n// const creds = await import(\r\n//   `../../../lib/.credentials/${credentialsName}.json`,\r\n//   {assert: {type: \"json\"}}\r\n// ).then((module) => module.default);\r\n```\r\n  \r\n### 創建JWT認證  \r\n  \r\n```js\r\nconst scopes = [\r\n    \"https://www.googleapis.com/auth/spreadsheets\",\r\n    \"https://www.googleapis.com/auth/drive.file\",\r\n  ];\r\n\r\n  const jwt = new google.auth.JWT({\r\n    email: creds.client_email,\r\n    key: creds.private_key,\r\n    scopes,\r\n  });\r\n```\r\n  \r\n### 最後fetch資料  \r\n  \r\n```\r\n  const rowNames = [\"title\", \"link\", \"imgName\"];//定義需要的row name\r\n\r\n  const doc = new GoogleSpreadsheet(docID, jwt);\r\n  await doc.loadInfo();\r\n  const sheet = doc.sheetsById[sheetID];\r\n  const rows = await sheet.getRows();\r\n  rows.forEach((row) => {\r\n    result.push(\r\n      rowNames.reduce((obj, name) => {\r\n        obj[name] = row.get(name);\r\n        return obj;\r\n      }, {} as obj)\r\n    );\r\n  });\r\n```\r\n\r\n[成果展示](/projects)"},{"number":22,"title":"更新網誌架構：GraphQL","createdAt":"2023-08-28T07:05:29Z","publishedAt":"2023-08-28T07:05:29Z","lastEditedAt":"2023-08-28T07:15:24Z","url":"https://github.com/superyngo/hakuba_template/discussions/22","category":{"name":"posts"},"labels":{"nodes":[{"name":"github","color":"7B5A6D"},{"name":"開發筆記","color":"F907A6"},{"name":"GraphQL","color":"3D6DF8"}]},"description":"用GraphQL建index","year":"2023","month":"8","date":"28","body":"---\nnumber: 22\ntitle: 更新網誌架構：GraphQL\ncreatedAt: 2023-08-28T07:05:29Z\npublishedAt: 2023-08-28T07:05:29Z\nlastEditedAt: 2023-08-28T07:15:24Z\nurl: https://github.com/superyngo/hakuba_template/discussions/22\ncategory:\n  name: posts\nlabels:\n  nodes:\n    - name: github\n      color: 7B5A6D\n    - name: 開發筆記\n      color: F907A6\n    - name: GraphQL\n      color: 3D6DF8\ndescription: 用GraphQL建index\nyear: \"2023\"\nmonth: \"8\"\ndate: \"28\"\n---\n\r\n如[前篇所說](https://yafdn.vercel.app/articles/2023/8/23/19])  \r\n現在是用github discussions建立網誌  \r\n透過GrqphQL轉成md檔再編譯  \r\n  \r\n又研究了一下，決定利用GrqphQL撈資料的特性重構了網誌的index  \r\n原本是在runtime時用import.meta.glob時把index及label清單建起來  \r\n現在在build時用GrqphQL撈成JSON檔就好了  \r\n  \r\n```js\r\n//GraphQL的呼叫語法\r\nconst fetchData = async <T>(query: string) => {\r\n  try {\r\n    const res = await fetch(githubGQLEndpoint, {\r\n      method: \"POST\",\r\n      headers: {\r\n        Authorization: `bearer ${GITHUB_TOKEN}`,\r\n        \"Content-Type\": \"application/json\", // Add this header for JSON content\r\n      },\r\n      body: query,\r\n    });\r\n    const json: any = await res.json();\r\n    return json.data as T;\r\n  } catch (e: unknown) {\r\n    console.error(\"Error:\", e); // Log the error message\r\n    throw new Error(\"Error fetching data.\"); // Rethrow the error\r\n  }\r\n};\r\n\r\n//query的語法(label作範例)\r\n  const variables = {\r\n    owner,\r\n    REPOSITORY,\r\n    lastPageEndCursor: undefined,\r\n  };\r\n  const query = `\r\n  query GetRepositoryLabels($owner: String!, $REPOSITORY: String!) {\r\n    repository(owner: $owner, name: $REPOSITORY) {\r\n      labels(first: 100) {\r\n        pageInfo {\r\n          hasNextPage\r\n          endCursor\r\n        }\r\n        nodes {\r\n          name\r\n          color\r\n        }\r\n      }\r\n    }\r\n  }\r\n//呼叫時先包成object再轉文字後傳入\r\nconst labels = await fetchData (JSON.stringify({\r\n        query: query,\r\n        variables: variables,\r\n      })\r\n`\r\n```\r\n順便更新了label的顏色和github上的一樣  \r\n  \r\n接下來要開始搞用mark直接編譯svelte component了  "},{"number":19,"title":"用Github discussion寫blog","createdAt":"2023-08-23T14:40:48Z","publishedAt":"2023-08-23T14:40:48Z","lastEditedAt":"2023-10-04T04:46:52Z","url":"https://github.com/superyngo/hakuba_template/discussions/19","category":{"name":"posts"},"labels":{"nodes":[{"name":"svelte/kit","color":"f9d0c4"},{"name":"github","color":"7B5A6D"}]},"slug":"githubDiscussionBlog","description":"用Github discussion寫blog","year":"2023","month":"8","date":"23","body":"---\nnumber: 19\ntitle: 用Github discussion寫blog\ncreatedAt: 2023-08-23T14:40:48Z\npublishedAt: 2023-08-23T14:40:48Z\nlastEditedAt: 2023-10-04T04:46:52Z\nurl: https://github.com/superyngo/hakuba_template/discussions/19\ncategory:\n  name: posts\nlabels:\n  nodes:\n    - name: svelte/kit\n      color: f9d0c4\n    - name: github\n      color: 7B5A6D\nslug: githubDiscussionBlog\ndescription: 用Github discussion寫blog\nyear: \"2023\"\nmonth: \"8\"\ndate: \"23\"\n---\n\r\n## Svelte/kit blog starters  \r\n建這個網站時  \r\n異想天開想在runtime從資料庫撈資料，然後直接將資料轉成component import  \r\n最後當然是失敗  \r\n(其實應該是做得到，但效率差，因為會不斷寫入磁碟，不過好像可以優化...等有時間再來試好了...)  \r\n總之在搜尋的過程中  \r\n找到[成功他媽．阿瑋](https://www.kwchang0831.dev/)這位大神  \r\n了解到Blog Starter  \r\n然後在[made with Svelte](https://madewithsvelte.com/boilerplate)上翻了一下  \r\n又發現這個專案[Hakuba](https://github.com/YeungKC/Hakuba)很有趣  \r\n用GraphQL撈gitbub discussion的資料匯成markdown file來寫blog  \r\n就把原碼移植一部分過來~  \r\n現在不用煩惱cms編輯頁面怎麼建了  \r\n可以直接在github discussion上寫網誌  \r\n支援md語法、svelte component載入\r\n還支援圖片功能  \r\n真的是很方便  \r\n\r\n\r\n![brooke-cagle-oTweoxMKdkA-unsplash](https://github.com/superyngo/hakuba_template/assets/12149732/322b3b2a-fcd0-4558-bc21-3ad30d9ed694)\r\nPhoto by <a href=\"https://unsplash.com/@brookecagle?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Brooke Cagle</a> on <a href=\"https://unsplash.com/photos/oTweoxMKdkA?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>  \r\n  \r\n\r\n\r\n\r\n"},{"number":14,"title":"用javascript+css做貪食蛇","createdAt":"2023-08-22T04:46:52Z","publishedAt":"2023/08/15","lastEditedAt":"2023-10-04T04:45:36Z","url":"https://github.com/superyngo/hakuba_template/discussions/14","category":{"name":"posts"},"labels":{"nodes":[{"name":"javcascript","color":"509AB1"},{"name":"開發筆記","color":"F907A6"}]},"slug":"aboutsnake","description":"從零打造貪食蛇","year":"2023","month":"8","date":"15","body":"---\nnumber: 14\ntitle: 用javascript+css做貪食蛇\ncreatedAt: 2023-08-22T04:46:52Z\npublishedAt: 2023/08/15\nlastEditedAt: 2023-10-04T04:45:36Z\nurl: https://github.com/superyngo/hakuba_template/discussions/14\ncategory:\n  name: posts\nlabels:\n  nodes:\n    - name: javcascript\n      color: 509AB1\n    - name: 開發筆記\n      color: F907A6\nslug: aboutsnake\ndescription: 從零打造貪食蛇\nyear: \"2023\"\nmonth: \"8\"\ndate: \"15\"\n---\n\r\n\r\n## 先做再說\r\n\r\n前端自學了半年，跟著[CodeLove 愛寫扣學院](https://codelove.tw/)從最基礎的 HTML+CSS 開始到 Vue Framework  \r\n但目前仍是待業中...汗  \r\n前陣子想說做看看貪食蛇  \r\n先用純 javascript 硬刻  \r\n花了兩晚 做出一個會動的版本  \r\n![Demo](/projects/snake-old.png)\r\nDemo：[Demo](https://superyngo.github.io/snake_spaghetti_style_code/)\r\n\r\n這版用 row 包 coulmn 做 X Y 定位  \r\n可以設定方塊數和速度  \r\n有基本的 RWD 和觸控支援\r\n\r\n## 用 SVELTE 做做看\r\n\r\n前陣子開始摸 SVELTE  \r\n就用 svelte 重新開發\r\n這版 XY 改用單 array 定位  \r\n左右移動為+-1  \r\n上下移動為+-width 設定值  \r\n跨邊界的邏輯也重新撰寫  \r\n蛇蛇有身體和臉\r\n![Demo](/projects/snake.png)\r\nDemo：[Demo](https://superyngo.github.io/snake_svelte3/)\r\n\r\n## 仿古 3310\r\n\r\n既然基本功能都做好了  \r\n就想說套個 3310 的皮看看  \r\n螢幕的部分用比例去定位\r\n結果最後卡關在\r\nfirefox 對`width=fit-content`的邏輯不如預期\r\n\r\n```css\r\n.phone {\r\n  @apply relative h-full m-auto border-4;\r\n  width: fit-content;\r\n}\r\n.phoneImage {\r\n  max-height: var(--image-height);\r\n}\r\n```\r\n\r\nphone 是 phoneImage 的 wrapper，  \r\n因為要用 phone 比例定位螢幕，  \r\n要設定他們一樣大  \r\n但因為 phoneImage 要 RWD，  \r\n原本設定`max-height: 100%`  \r\n在 chome 和 edge 都符合預期  \r\n但 firefox 的 wrapper 只要 content 的 height 不是固定值而是比例，  \r\n那`width: fit-content`就會直接變成 100%  \r\n![width fail](/projects/width_fail.png)\r\n最後還是用 javascript 設定 image 的 height 才解決  \r\n頭很痛\r\n\r\n![Demo](/projects/snake3310.png)\r\nDemo：[Demo](https://yafdn.vercel.app/projects/Notkia3310)\r\n\r\n以上，希望早日找到工作！！\r\n"},{"number":13,"title":"Postgres操作技巧:JSON","createdAt":"2023-08-22T04:46:13Z","publishedAt":"2023/08/14","lastEditedAt":"2023-08-25T04:17:09Z","url":"https://github.com/superyngo/hakuba_template/discussions/13","category":{"name":"posts"},"labels":{"nodes":[{"name":"Postgres","color":"CC87D9"},{"name":"database","color":"7A17AA"}]},"slug":"PostgresJson","description":"用Postgres操作json","year":"2023","month":"8","date":"14","body":"---\nnumber: 13\ntitle: Postgres操作技巧:JSON\ncreatedAt: 2023-08-22T04:46:13Z\npublishedAt: 2023/08/14\nlastEditedAt: 2023-08-25T04:17:09Z\nurl: https://github.com/superyngo/hakuba_template/discussions/13\ncategory:\n  name: posts\nlabels:\n  nodes:\n    - name: Postgres\n      color: CC87D9\n    - name: database\n      color: 7A17AA\nslug: PostgresJson\ndescription: 用Postgres操作json\nyear: \"2023\"\nmonth: \"8\"\ndate: \"14\"\n---\n\r\n\r\nPostgres 是物件導向資料庫，  \r\n可以定義 custom type 對應 object 的 property\r\n\r\n```sql\r\nCREATE TYPE metatype as (\r\n  title VARCHAR(255),\r\n  description VARCHAR(255),\r\n  date DATE,\r\n  categories VARCHAR(255)[255],\r\n  published boolean\r\n)\r\n--INSERT VALUE 時用ROW()包，有ARRAY用ARRAY[]包\r\nROW('First post',\r\n  'First post.',\r\n  '2023/04/14',\r\n  ARRAY[\r\n      'sveltekit', 'svelte',\r\n      'lorem',     'lorem1',\r\n      'lorem2',    'lorem3',\r\n      'lorem4',    'lorem5'\r\n    ],\r\n  'true')\r\n```\r\n\r\n後續就可以針對 object property 操作\r\n\r\n更簡單的方式是把資料存成 json  \r\n直接 query 或 set json 的 property\r\n\r\n```sql\r\nINSERT INTO posts (metadata)\r\nVALUES\r\n(\r\n'{\r\n  \"title\": \"First post\",\r\n  \"description\": \"First post.\",\r\n  \"date\": \"2023-4-14\",\r\n  \"categories\": [\r\n    \"sveltekit\",\r\n    \"svelte\",\r\n  ],\r\n  \"published\": true\r\n}'::json\r\n)\r\n```\r\n\r\n### SELECT\r\n\r\n```\r\n--SELECT 用->符號回傳原值\r\nSELECT metadata->'published' FROM posts\r\nWHERE id= 1\r\n--SELECT 用->>符號回傳text\r\nSELECT slug FROM posts\r\nWHERE metadata->>'published' = 'true';\r\n--用ANY搜尋ARRAY\r\nSELECT slug FROM posts\r\nWHERE 'sveltekit' = ANY(string_to_array(metadata->>'categories', ','))\r\n```\r\n\r\n### SET\r\n\r\n```\r\nUPDATE posts\r\nSET metadata = jsonb_set(metadata ::jsonb, '{date}'::text[] , '\"2023/08/01\"'::jsonb, false)\r\nwhere id= 1\r\n--jsonb_set語法\r\njsonb_set(\r\n  target JSONB, path TEXT[], new_value JSONB[, create_if_missing BOOLEAN]\r\n) -> JSONB\r\n```\r\n\r\n參考資料：  \r\n[JSON Functions and Operators](https://www.postgresql.org/docs/9.3/functions-json.html)  \r\n[PostgreSQL jsonb_set() 函数](https://www.sjkjc.com/postgresql-ref/jsonb_set/)  \r\n[PostgreSQL in 100 Seconds(youtube)](https://www.youtube.com/watch?v=n2Fluyr3lbc)\r\n"}]